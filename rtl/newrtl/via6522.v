//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// Sat Feb 19 2022 14:30:31
//
//      Input file      : 
//      Component name  : via6522
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// (C) COPYRIGHT 2007-2017, Gideon's Logic Architectures
//
//-----------------------------------------------------------------------------
// Title      : VIA 6522
//-----------------------------------------------------------------------------
// Author     : Gideon Zweijtzer  <gideon.zweijtzer@gmail.com>
//-----------------------------------------------------------------------------
// Description: This module implements the 6522 VIA chip.
//              Please note: A LOT OF REVERSE ENGINEERING has been done to
//              make this module as accurate as it is now. Please do not copy
//              (use in your own projects) without written permission of the
//              author.
//-----------------------------------------------------------------------------

module via6522(
    clock,
    rising,
    falling,
    reset,
    addr,
    wen,
    ren,
    data_in,
    data_out,
    phi2_ref,
    port_a_o,
    port_a_t,
    port_a_i,
    port_b_o,
    port_b_t,
    port_b_i,
    ca1_i,
    ca2_o,
    ca2_i,
    ca2_t,
    cb1_o,
    cb1_i,
    cb1_t,
    cb2_o,
    cb2_i,
    cb2_t,
    irq
);
    input            clock;
    input            rising;
    input            falling;
    input            reset;
    
    input [3:0]      addr;
    input            wen;
    input            ren;
    input [7:0]      data_in;
    output reg [7:0] data_out;
    
    output reg       phi2_ref;
    
    // pio --
    output [7:0]     port_a_o;
    output [7:0]     port_a_t;
    input [7:0]      port_a_i;
    
    output [7:0]     port_b_o;
    output [7:0]     port_b_t;
    input [7:0]      port_b_i;
    
    // handshake pins
    input            ca1_i;
    
    output           ca2_o;
    input            ca2_i;
    output           ca2_t;
    
    output           cb1_o;
    input            cb1_i;
    output           cb1_t;
    
    output           cb2_o;
    input            cb2_i;
    output           cb2_t;
    
    output           irq;
    
    
    
    parameter [7:0]  pio_default_pra = 1'b0;
    parameter [7:0]  pio_default_ddra = 1'b0;
    parameter [7:0]  pio_default_prb = 1'b0;
    parameter [7:0]  pio_default_ddrb = 1'b0;
    parameter [15:0] latch_reset_pattern = 16'h5550;
    
    reg [7:0]        last_data;
    
    reg [7:0]        pio_i_pra;
    reg [7:0]        pio_i_ddra;
    reg [7:0]        pio_i_prb;
    reg [7:0]        pio_i_ddrb;
    reg [7:0]        port_a_c;
    reg [7:0]        port_b_c;
    
    reg [6:0]        irq_mask;
    reg [6:0]        irq_flags;
    wire [6:0]       irq_events;
    reg              irq_out;
    
    reg [15:0]       timer_a_latch;
    reg [15:0]       timer_b_latch;
    reg [15:0]       timer_a_count;
    reg [15:0]       timer_b_count;
    wire             timer_a_out;
    reg              timer_b_tick;
    
    reg [7:0]        acr;
    reg [7:0]        pcr;
    reg [7:0]        shift_reg;
    wire             serport_en;
    reg              ser_cb2_o;
    wire             hs_cb2_o;
    reg              trigger_serial;
    
    `define ca2_event irq_events[0]
    `define ca1_event irq_events[1]
    `define serial_event irq_events[2]
    `define cb2_event irq_events[3]
    `define cb1_event irq_events[4]
    `define timer_b_event irq_events[5]
    `define timer_a_event irq_events[6]
    
    `define ca2_flag irq_flags[0]
    `define ca1_flag irq_flags[1]
    `define serial_flag irq_flags[2]
    `define cb2_flag irq_flags[3]
    `define cb1_flag irq_flags[4]
    `define timer_b_flag irq_flags[5]
    `define timer_a_flag irq_flags[6]
    
    `define tmr_a_output_en acr[7]
    `define tmr_a_freerun acr[6]
    `define tmr_b_count_mode acr[5]
    `define shift_dir acr[4]
    `define shift_clk_sel acr[3:2]
    `define shift_mode_control acr[4:2]
    `define pb_latch_en acr[1]
    `define pa_latch_en acr[0]
    
    `define cb2_is_output pcr[7]
    `define cb2_edge_select pcr[6]		// for when CB2 is input
    `define cb2_no_irq_clr pcr[5]		// for when CB2 is input
    `define cb2_out_mode pcr[6:5]
    `define cb1_edge_select pcr[4]
    
    `define ca2_is_output pcr[3]
    `define ca2_edge_select pcr[2]		// for when CA2 is input
    `define ca2_no_irq_clr pcr[1]		// for when CA2 is input
    `define ca2_out_mode pcr[2:1]
    `define ca1_edge_select pcr[0]
    
    reg [7:0]        ira;
    reg [7:0]        irb;
    
    wire             write_t1c_h;
    wire             write_t2c_h;
    
    reg              ca1_c;
    reg              ca2_c;
    reg              cb1_c;
    reg              cb2_c;
    reg              ca1_d;
    reg              ca2_d;
    reg              cb1_d;
    reg              cb2_d;
    
    reg              ca2_handshake_o;
    reg              ca2_pulse_o;
    reg              cb2_handshake_o;
    reg              cb2_pulse_o;
    reg              shift_active;
    assign irq = irq_out;
    
    assign write_t1c_h = (addr == 4'h5 & wen == 1'b1 & falling == 1'b1) ? 1'b1 : 
                         1'b0;
    assign write_t2c_h = (addr == 4'h9 & wen == 1'b1 & falling == 1'b1) ? 1'b1 : 
                         1'b0;
    
    assign `ca1_event = (ca1_c ^ ca1_d) & (ca1_d ^ `ca1_edge_select);
    assign `ca2_event = (ca2_c ^ ca2_d) & (ca2_d ^ `ca2_edge_select);
    assign `cb1_event = (cb1_c ^ cb1_d) & (cb1_d ^ `cb1_edge_select);
    assign `cb2_event = (cb2_c ^ cb2_d) & (cb2_d ^ `cb2_edge_select);
    
    assign ca2_t = `ca2_is_output;
    assign cb2_t = (serport_en == 1'b0) ? `cb2_is_output : 
                   `shift_dir;
    assign cb2_o = (serport_en == 1'b0) ? hs_cb2_o : 
                   ser_cb2_o;
    
    assign ca2_o = (`ca2_out_mode == 2'b00) ? ca2_handshake_o : 
                   (`ca2_out_mode == 2'b01) ? ca2_pulse_o : 
                   (`ca2_out_mode == 2'b10) ? 1'b0 : 
                   1'b1;
    
    assign hs_cb2_o = (`cb2_out_mode == 2'b00) ? cb2_handshake_o : 
                      (`cb2_out_mode == 2'b01) ? cb2_pulse_o : 
                      (`cb2_out_mode == 2'b10) ? 1'b0 : 
                      1'b1;
    
    
    always @(irq_flags or irq_mask)
        if ((irq_flags & irq_mask) == 7'b0000000)
            irq_out <= 1'b0;
        else
            irq_out <= 1'b1;
    
    
    always @(posedge clock)
        
        begin
            if (rising == 1'b1)
                phi2_ref <= 1'b1;
            else if (falling == 1'b1)
                phi2_ref <= 1'b0;
        end
    
    
    always @(posedge clock)
        
        begin
            // CA1/CA2/CB1/CB2 edge detect flipflops
            ca1_c <= To_X01(ca1_i);
            ca2_c <= To_X01(ca2_i);
            cb1_c <= To_X01(cb1_i);
            cb2_c <= To_X01(cb2_i);
            
            ca1_d <= ca1_c;
            ca2_d <= ca2_c;
            cb1_d <= cb1_c;
            cb2_d <= cb2_c;
            
            // input registers
            port_a_c <= port_a_i;
            port_b_c <= port_b_i;
            
            // input latch emulation
            if (`pa_latch_en == 1'b0 | `ca1_event == 1'b1)
                ira <= port_a_c;
            
            if (`pb_latch_en == 1'b0 | `cb1_event == 1'b1)
                irb <= port_b_c;
            
            // CA2 logic
            if (`ca1_event == 1'b1)
                ca2_handshake_o <= 1'b1;
            else if ((ren == 1'b1 | wen == 1'b1) & addr == 4'h1 & falling == 1'b1)
                ca2_handshake_o <= 1'b0;
            
            if (falling == 1'b1)
            begin
                if ((ren == 1'b1 | wen == 1'b1) & addr == 4'h1)
                    ca2_pulse_o <= 1'b0;
                else
                    ca2_pulse_o <= 1'b1;
            end
            
            // CB2 logic
            if (`cb1_event == 1'b1)
                cb2_handshake_o <= 1'b1;
            else if ((ren == 1'b1 | wen == 1'b1) & addr == 4'h0 & falling == 1'b1)
                cb2_handshake_o <= 1'b0;
            
            if (falling == 1'b1)
            begin
                if ((ren == 1'b1 | wen == 1'b1) & addr == 4'h0)
                    cb2_pulse_o <= 1'b0;
                else
                    cb2_pulse_o <= 1'b1;
            end
            
            // Interrupt logic
            irq_flags <= irq_flags | irq_events;
            
            if (falling == 1'b1)
                trigger_serial <= 1'b0;
            
            // Writes --
            if (wen == 1'b1 & falling == 1'b1)
            begin
                last_data <= data_in;
                case (addr)
                    4'h0 :		// ORB
                        begin
                            pio_i_prb <= data_in;
                            if (`cb2_no_irq_clr == 1'b0)
                                `cb2_flag <= 1'b0;
                            `cb1_flag <= 1'b0;
                        end
                    
                    4'h1 :		// ORA
                        begin
                            pio_i_pra <= data_in;
                            if (`ca2_no_irq_clr == 1'b0)
                                `ca2_flag <= 1'b0;
                            `ca1_flag <= 1'b0;
                        end
                    
                    4'h2 :		// DDRB
                        pio_i_ddrb <= data_in;
                    
                    4'h3 :		// DDRA
                        pio_i_ddra <= data_in;
                    
                    4'h4 :		// TA LO counter (write=latch)
                        timer_a_latch[7:0] <= data_in;
                    
                    4'h5 :		// TA HI counter
                        begin
                            timer_a_latch[15:8] <= data_in;
                            `timer_a_flag <= 1'b0;
                        end
                    
                    4'h6 :		// TA LO latch
                        timer_a_latch[7:0] <= data_in;
                    
                    4'h7 :		// TA HI latch
                        begin
                            timer_a_latch[15:8] <= data_in;
                            `timer_a_flag <= 1'b0;
                        end
                    
                    4'h8 :		// TB LO latch
                        timer_b_latch[7:0] <= data_in;
                    
                    4'h9 :		// TB HI counter
                        `timer_b_flag <= 1'b0;
                    
                    4'hA :		// Serial port
                        begin
                            `serial_flag <= 1'b0;
                            if (shift_active == 1'b0)
                                trigger_serial <= 1'b1;
                        end
                    
                    4'hB :		// ACR (Auxiliary Control Register)
                        acr <= data_in;
                    
                    4'hC :		// PCR (Peripheral Control Register)
                        pcr <= data_in;
                    
                    4'hD :		// IFR
                        irq_flags <= irq_flags & (~data_in[6:0]);
                    
                    4'hE :		// IER
                        if (data_in[7] == 1'b1)		// set
                            irq_mask <= irq_mask | data_in[6:0];
                        else
                            // clear
                            irq_mask <= irq_mask & (~data_in[6:0]);
                    
                    4'hF :		// ORA no handshake
                        pio_i_pra <= data_in;
                    
                    default :
                        ;
                endcase
            end
            
            // Reads - Output only --
            data_out <= 8'h00;
            case (addr)
                4'h0 :		// ORB
                    //Port B reads its own output register for pins set to output.
                    data_out <= (pio_i_prb & pio_i_ddrb) | (irb & (~pio_i_ddrb));
                4'h1 :		// ORA
                    data_out <= ira;
                4'h2 :		// DDRB
                    data_out <= pio_i_ddrb;
                4'h3 :		// DDRA
                    data_out <= pio_i_ddra;
                4'h4 :		// TA LO counter
                    data_out <= timer_a_count[7:0];
                4'h5 :		// TA HI counter
                    data_out <= timer_a_count[15:8];
                4'h6 :		// TA LO latch
                    data_out <= timer_a_latch[7:0];
                4'h7 :		// TA HI latch
                    data_out <= timer_a_latch[15:8];
                4'h8 :		// TA LO counter
                    data_out <= timer_b_count[7:0];
                4'h9 :		// TA HI counter
                    data_out <= timer_b_count[15:8];
                4'hA :		// SR
                    data_out <= shift_reg;
                4'hB :		// ACR
                    data_out <= acr;
                4'hC :		// PCR
                    data_out <= pcr;
                4'hD :		// IFR
                    data_out <= {irq_out, irq_flags};
                4'hE :		// IER
                    data_out <= {1'b0, irq_mask};
                4'hF :		// ORA
                    data_out <= ira;
                default :
                    ;
            endcase
            
            // Read actions --
            if (ren == 1'b1 & falling == 1'b1)
                case (addr)
                    4'h0 :		// ORB
                        begin
                            if (`cb2_no_irq_clr == 1'b0)
                                `cb2_flag <= 1'b0;
                            `cb1_flag <= 1'b0;
                        end
                    
                    4'h1 :		// ORA
                        begin
                            if (`ca2_no_irq_clr == 1'b0)
                                `ca2_flag <= 1'b0;
                            `ca1_flag <= 1'b0;
                        end
                    
                    4'h4 :		// TA LO counter
                        `timer_a_flag <= 1'b0;
                    
                    4'h8 :		// TB LO counter
                        `timer_b_flag <= 1'b0;
                    
                    4'hA :		// SR
                        begin
                            `serial_flag <= 1'b0;
                            trigger_serial <= 1'b1;
                        end
                    
                    default :
                        ;
                endcase
            
            if (reset == 1'b1)
            begin
                {pio_i_ddra, pio_i_ddrb, pio_i_pra, pio_i_prb} <= {pio_default_ddra, pio_default_ddrb, pio_default_pra, pio_default_prb};
                irq_mask <= {7{1'b0}};
                irq_flags <= {7{1'b0}};
                acr <= {8{1'b0}};
                pcr <= {8{1'b0}};
                ca2_handshake_o <= 1'b1;
                ca2_pulse_o <= 1'b1;
                cb2_handshake_o <= 1'b1;
                cb2_pulse_o <= 1'b1;
                timer_a_latch <= latch_reset_pattern;
                timer_b_latch <= latch_reset_pattern;
                trigger_serial <= 1'b0;
            end
        end
    
    // PIO Out select --
    assign port_a_o = pio_i_pra;
    assign port_b_o[6:0] = pio_i_prb[6:0];
    assign port_b_o[7] = (`tmr_a_output_en == 1'b0) ? pio_i_prb[7] : 
                         timer_a_out;
    
    assign port_a_t = pio_i_ddra;
    assign port_b_t[6:0] = pio_i_ddrb[6:0];
    assign port_b_t[7] = pio_i_ddrb[7] | `tmr_a_output_en;
    
    // Timer A
    // <XHDL: tmr_a : block unsupported>
    reg              timer_a_reload;
    reg              timer_a_oneshot_trig;
    reg              timer_a_toggle;
    
    always @(posedge clock)
        
        begin
            if (falling == 1'b1)
            begin
                // always count, or load
                
                if (timer_a_reload == 1'b1)
                begin
                    timer_a_count <= timer_a_latch;
                    timer_a_reload <= 1'b0;
                    timer_a_oneshot_trig <= 1'b0;
                end
                else
                begin
                    if (timer_a_count == 16'h0000)
                        // generate an event if we were triggered
                        timer_a_reload <= 1'b1;
                    //Timer coutinues to count in both free run and one shot.                        
                    timer_a_count <= timer_a_count - 16'h0001;
                end
            end
            
            if (rising == 1'b1)
            begin
                if (`timer_a_event == 1'b1)
                    timer_a_toggle <= (~timer_a_toggle);
            end
            
            if (write_t1c_h == 1'b1)
            begin
                timer_a_toggle <= 1'b0;
                timer_a_count <= {data_in, timer_a_latch[7:0]};
                timer_a_reload <= 1'b0;
                timer_a_oneshot_trig <= 1'b1;
            end
            
            if (reset == 1'b1)
            begin
                timer_a_toggle <= 1'b1;
                timer_a_count <= latch_reset_pattern;
                timer_a_reload <= 1'b0;
                timer_a_oneshot_trig <= 1'b0;
            end
        end
    
    always @(*) timer_a_out <= timer_a_toggle;
    always @(*) `timer_a_event <= rising & timer_a_reload & (`tmr_a_freerun | timer_a_oneshot_trig);
    // <XHDL: end block; unsupported>
    
    // Timer B
    // <XHDL: tmr_b : block unsupported>
    reg              timer_b_reload_lo;
    reg              timer_b_oneshot_trig;
    reg              timer_b_timeout;
    reg              pb6_c;
    reg              pb6_d;
    
    always @(posedge clock)
    begin: xhdl0
        reg              timer_b_decrement;
        
        begin
            timer_b_decrement = 1'b0;
            
            if (rising == 1'b1)
            begin
                pb6_c <= To_X01(port_b_i[6]);
                pb6_d <= pb6_c;
            end
            
            if (falling == 1'b1)
            begin
                timer_b_timeout <= 1'b0;
                timer_b_tick <= 1'b0;
                
                if (`tmr_b_count_mode == 1'b1)
                begin
                    if (pb6_d == 1'b1 & pb6_c == 1'b0)
                        timer_b_decrement = 1'b1;
                end
                else
                    // one shot or used for shift register
                    timer_b_decrement = 1'b1;
                
                if (timer_b_decrement == 1'b1)
                begin
                    if (timer_b_count == 16'h0000)
                    begin
                        if (timer_b_oneshot_trig == 1'b1)
                        begin
                            timer_b_oneshot_trig <= 1'b0;
                            timer_b_timeout <= 1'b1;
                        end
                    end
                    if (timer_b_count[7:0] == 8'h00)
                        case (`shift_mode_control)
                            3'b001, 3'b101, 3'b100 :
                                begin
                                    timer_b_reload_lo <= 1'b1;
                                    timer_b_tick <= 1'b1;
                                end
                            default :
                                ;
                        endcase
                    timer_b_count <= timer_b_count - 16'h0001;
                end
                if (timer_b_reload_lo == 1'b1)
                begin
                    timer_b_count[7:0] <= timer_b_latch[7:0];
                    timer_b_reload_lo <= 1'b0;
                end
            end
            
            if (write_t2c_h == 1'b1)
            begin
                timer_b_count <= {data_in, timer_b_latch[7:0]};
                timer_b_oneshot_trig <= 1'b1;
            end
            
            if (reset == 1'b1)
            begin
                timer_b_count <= latch_reset_pattern;
                timer_b_reload_lo <= 1'b0;
                timer_b_oneshot_trig <= 1'b0;
            end
        end
    end
    
    always @(*) `timer_b_event <= rising & timer_b_timeout;
    // <XHDL: end block; unsupported>
    
    // <XHDL: ser : block unsupported>
    reg              shift_clock_d;
    reg              shift_clock;
    reg              shift_tick_r;
    reg              shift_tick_f;
    reg              cb2_c;
    reg [2:0]        bit_cnt;
    reg              shift_pulse;
    
    always @(shift_active or timer_b_tick or `shift_clk_sel or shift_clock or shift_clock_d)
    begin
        case (`shift_clk_sel)
            2'b10 :
                shift_pulse <= 1'b1;
            
            2'b00, 2'b01 :
                shift_pulse <= timer_b_tick;
            
            default :
                shift_pulse <= shift_clock & (~shift_clock_d);
        endcase
        
        if (shift_active == 1'b0)
            shift_pulse <= 1'b0;
    end
    
    
    always @(posedge clock)
        
        begin
            if (rising == 1'b1)
            begin
                cb2_c <= To_X01(cb2_i);
                
                if (shift_active == 1'b0)
                    shift_clock <= 1'b1;
                else if (`shift_clk_sel == 2'b11)
                    shift_clock <= To_X01(cb1_i);
                else if (shift_pulse == 1'b1)
                    shift_clock <= (~shift_clock);
                
                shift_clock_d <= shift_clock;
                
                if (shift_tick_f == 1'b1)
                    ser_cb2_o <= shift_reg[7];
            end
            if (reset == 1'b1)
            begin
                shift_clock <= 1'b1;
                shift_clock_d <= 1'b1;
                ser_cb2_o <= 1'b1;
            end
        end
    
    always @(*) cb1_t <= (`shift_clk_sel == 2'b11) ? 1'b0 : 
                         serport_en;
    always @(*) cb1_o <= shift_clock_d;
    
    always @(*) serport_en <= `shift_dir | `shift_clk_sel[1] | `shift_clk_sel[0];
    
    
    always @(posedge clock)
        
        begin
            if (reset == 1'b1)
            begin
                shift_reg <= 8'hFF;
                shift_tick_r <= 1'b0;
                shift_tick_f <= 1'b0;
            end
            else if (falling == 1'b1)
            begin
                shift_tick_r <= (~shift_clock_d) & shift_clock;
                shift_tick_f <= shift_clock_d & (~shift_clock);
                
                if (wen == 1'b1 & addr == 4'hA)
                    shift_reg <= data_in;
                else if (shift_tick_r == 1'b1)
                begin
                    if (`shift_dir == 1'b1)		// output
                        shift_reg <= {shift_reg[6:0], shift_reg[7]};
                    else
                        shift_reg <= {shift_reg[6:0], cb2_c};
                end
            end
        end
    
    // tell people that we're ready!
    always @(*) `serial_event <= shift_tick_r & (~shift_active) & rising;
    
    
    always @(posedge clock)
        
        begin
            if (falling == 1'b1)
            begin
                if (shift_active == 1'b0)
                begin
                    if (trigger_serial == 1'b1)
                    begin
                        bit_cnt <= 7;
                        shift_active <= 1'b1;
                    end
                end
                else
                    // we're active
                    if (`shift_clk_sel == 2'b00)
                        shift_active <= `shift_dir;		// when '1' we're active, but for mode 000 we go inactive.
                    else if (shift_pulse == 1'b1 & shift_clock == 1'b1)
                    begin
                        if (bit_cnt == 0)
                            shift_active <= 1'b0;
                        else
                            bit_cnt <= bit_cnt - 1;
                    end
            end
            
            if (reset == 1'b1)
            begin
                shift_active <= 1'b0;
                bit_cnt <= 0;
            end
        end
    // <XHDL: end block; unsupported>
    
endmodule
