//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// Sat Mar 5 2022 16:56:58
//
//      Input file      : 
//      Component name  : ur6805
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------

// mul8
//-----------------------------------------------------------------------
// begin of 6805

module UR6805(
    clk,
    rst,
    irq,
    addr,
    wr,
    datain,
    state,
    dataout
);
    input           clk;
    input           rst;
    input           irq;
    output [15:0]   addr;
    output reg      wr;
    input [7:0]     datain;
    output [3:0]    state;
    output [7:0]    dataout;
    
    
    parameter       CPUread = 1'b1;
    parameter       CPUwrite = 1'b0;
    parameter [2:0] addrPC = 3'b000;
    parameter [2:0] addrSP = 3'b001;
    parameter [2:0] addrHX = 3'b010;
    parameter [2:0] addrTM = 3'b011;
    parameter [2:0] addrX2 = 3'b100;
    parameter [2:0] addrS2 = 3'b101;
    parameter [2:0] addrX1 = 3'b110;
    parameter [2:0] addrS1 = 3'b111;
    parameter [3:0] outA = 4'b0000;
    parameter [3:0] outH = 4'b0001;
    parameter [3:0] outX = 4'b0010;
    parameter [3:0] outSPL = 4'b0011;
    parameter [3:0] outSPH = 4'b0100;
    parameter [3:0] outPCL = 4'b0101;
    parameter [3:0] outPCH = 4'b0110;
    parameter [3:0] outTL = 4'b0111;
    parameter [3:0] outTH = 4'b1000;
    parameter [3:0] outHelp = 4'b1001;
    parameter [3:0] outCode = 4'b1010;
    
    reg [7:0]       mask0[0:7];
    reg [7:0]       mask1[0:7];
    reg [7:0]       regA;
    reg [7:0]       regX;
    reg [15:0]      regSP;
    reg [15:0]      regPC;
    reg             flagH;
    reg             flagI;
    reg             flagN;
    reg             flagZ;
    reg             flagC;
    reg [7:0]       help;
    reg [15:0]      temp;
    reg [3:0]       mainFSM;
    reg [2:0]       addrMux;
    reg [3:0]       dataMux;
    reg [7:0]       opcode;
    wire [15:0]     prod;
    reg             irq_d;
    reg             irqRequest;
    
    reg             trace;
    reg             trace_i;
    reg [7:0]       traceOpCode;
    
    
    mul8 mul(
        .a(regA),
        .b(regX),
        .prod(prod)
    );
    
    assign addr = (addrMux == addrPC) ? regPC : 
                  (addrMux == addrSP) ? regSP : 
                  (addrMux == addrHX) ? {8'h00, regX} : 
                  (addrMux == addrTM) ? temp : 
                  (addrMux == addrX2) ? (({8'h00, regX}) + temp) : 
                  (addrMux == addrS2) ? (regSP + temp) : 
                  (addrMux == addrX1) ? (({8'h00, regX}) + ({8'h00, temp[7:0]})) : 
                  (regSP + ({8'h00, temp[7:0]}));
    assign dataout = (dataMux == outA) ? regA : 
                     (dataMux == outH) ? regX : 
                     (dataMux == outX) ? regX : 
                     (dataMux == outSPL) ? regSP[7:0] : 
                     (dataMux == outSPH) ? regSP[15:8] : 
                     (dataMux == outPCL) ? regPC[7:0] : 
                     (dataMux == outPCH) ? regPC[15:8] : 
                     (dataMux == outTL) ? temp[7:0] : 
                     (dataMux == outTH) ? temp[15:8] : 
                     (dataMux == outHelp) ? help : 
                     traceOpCode;
    
    assign state = mainFSM;
    
    always @(posedge clk or negedge rst)
    begin: xhdl3
        reg [7:0]       tres;
        reg [15:0]      lres;
        if (rst == 1'b0)
        begin
            trace <= 1'b0;
            trace_i <= 1'b0;
            mask0[0] <= 8'b11111110;
            mask0[1] <= 8'b11111101;
            mask0[2] <= 8'b11111011;
            mask0[3] <= 8'b11110111;
            mask0[4] <= 8'b11101111;
            mask0[5] <= 8'b11011111;
            mask0[6] <= 8'b10111111;
            mask0[7] <= 8'b01111111;
            mask1[0] <= 8'b00000001;
            mask1[1] <= 8'b00000010;
            mask1[2] <= 8'b00000100;
            mask1[3] <= 8'b00001000;
            mask1[4] <= 8'b00010000;
            mask1[5] <= 8'b00100000;
            mask1[6] <= 8'b01000000;
            mask1[7] <= 8'b10000000;
            wr <= CPUread;
            flagH <= 1'b0;
            flagI <= 1'b1;		// irq disabled
            flagN <= 1'b0;
            flagZ <= 1'b0;
            flagC <= 1'b0;
            regA <= 8'h00;
            regX <= 8'h00;
            regSP <= 16'h00FF;
            regPC <= 16'hFFFE;
            temp <= 16'hFFFE;
            help <= 8'h00;
            dataMux <= outA;
            addrMux <= addrTM;
            irq_d <= 1'b1;
            irqRequest <= 1'b0;
            mainFSM <= 4'b0000;
        end
        else
            
            begin
                irq_d <= irq;
                if ((irq <= 1'b0) & (irq_d == 1'b1) & (flagI == 1'b0))		// irq falling edge ?
                    irqRequest <= 1'b1;
                case (mainFSM)
                    4'b0000 :		//############# reset fetch PCH from FFFE
                        begin
                            regPC[15:8] <= datain;
                            temp <= temp + 1;
                            mainFSM <= 4'b0001;
                        end
                    4'b0001 :		//############# reset fetch PCL from FFFF
                        begin
                            regPC[7:0] <= datain;
                            addrMux <= addrPC;
                            mainFSM <= 4'b0010;
                        end
                    
                    4'b0010 :		//##################### fetch opcode, instruction cycle 1
                        begin
                            trace <= trace_i;
                            if (trace == 1'b1)
                            begin
                                opcode <= 8'h83;		// special SWI trace
                                traceOpCode <= datain;
                                addrMux <= addrSP;
                                mainFSM <= 4'b0011;
                            end
                            else if (irqRequest == 1'b1)
                            begin
                                opcode <= 8'h83;		// special SWI interrupt
                                addrMux <= addrSP;
                                mainFSM <= 4'b0011;
                            end
                            else
                            begin
                                opcode <= datain;
                                case (datain)
                                    8'h82 :		// RTT return trace special propietary instruction
                                        begin
                                            trace_i <= 1'b1;		// arm trace for next instruction
                                            regSP <= regSP + 1;
                                            addrMux <= addrSP;
                                            mainFSM <= 4'b0011;
                                        end
                                    // BRSET n,opr8a,rel
                                    // BRCLR n,opr8a,rel
                                    // BSET n,opr8a
                                    // BCLR n,opr8a
                                    // NEG opr8a, COM opr8a, LSR opr8a
                                    // ROR opr8a, ASR opr8a, LSL opr8a
                                    // ROL opr8a, DEC opr8a, INC opr8a
                                    // TST opr8a, CLR opr8a
                                    // SUB opr8a, CMP opr8a, SBC opr8a, CPX opr8a
                                    // AND opr8a, BIT opr8a, LDA opr8a, STA opr8a
                                    // EOR opr8a, ADC opr8a, ORA opr8a, ADD opr8a
                                    8'h00, 8'h02, 8'h04, 8'h06, 8'h08, 8'h0A, 8'h0C, 8'h0E, 8'h01, 8'h03, 8'h05, 8'h07, 8'h09, 8'h0B, 8'h0D, 8'h0F, 8'h10, 8'h12, 8'h14, 8'h16, 8'h18, 8'h1A, 8'h1C, 8'h1E, 8'h11, 8'h13, 8'h15, 8'h17, 8'h19, 8'h1B, 8'h1D, 8'h1F, 8'h30, 8'h33, 8'h34, 8'h36, 8'h37, 8'h38, 8'h39, 8'h3A, 8'h3C, 8'h3D, 8'h3F, 8'hB0, 8'hB1, 8'hB2, 8'hB3, 8'hB4, 8'hB5, 8'hB6, 8'hB7, 8'hB8, 8'hB9, 8'hBA, 8'hBB, 8'hBC, 8'hBE, 8'hBF :		// JMP opr8a, LDX opr8a, STX opr8a
                                        begin
                                            temp <= 16'h0000;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0011;
                                        end
                                    // branches
                                    // SUB opr16a, CMP opr16a, SBC opr16a, CPX opr16a
                                    // AND opr16a, BIT opr16a, LDA opr16a, STA opr16a
                                    // EOR opr16a, ADC opr16a, ORA opr16a, ADD opr16a
                                    // JMP opr16a, LDX opr16a, STX opr16a
                                    // SUB oprx16,X, CMP oprx16,X, SBC oprx16,X, CPX oprx16,X
                                    // AND oprx16,X, BIT oprx16,X, LDA oprx16,X, STA oprx16,X
                                    // EOR oprx16,X, ADC oprx16,X, ORA oprx16,X, ADD oprx16,X
                                    8'h20, 8'h21, 8'h22, 8'h23, 8'h24, 8'h25, 8'h26, 8'h27, 8'h28, 8'h29, 8'h2A, 8'h2B, 8'h2C, 8'h2D, 8'h2E, 8'h2F, 8'hC0, 8'hC1, 8'hC2, 8'hC3, 8'hC4, 8'hC5, 8'hC6, 8'hC7, 8'hC8, 8'hC9, 8'hCA, 8'hCB, 8'hCC, 8'hCE, 8'hCF, 8'hD0, 8'hD1, 8'hD2, 8'hD3, 8'hD4, 8'hD5, 8'hD6, 8'hD7, 8'hD8, 8'hD9, 8'hDA, 8'hDB, 8'hDC, 8'hDE, 8'hDF :		// JMP oprx16,X, LDX oprx16,X, STX oprx16,X
                                        begin
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0011;
                                        end
                                    // NEG ,X, COM ,X, LSR ,X, ROR ,X, ASR ,X
                                    8'h70, 8'h73, 8'h74, 8'h76, 8'h77, 8'h78, 8'h79, 8'h7A, 8'h7C, 8'h7D :		// LSL ,X, ROL ,X, DEC ,X, INC ,X, TXT ,X
                                        begin
                                            addrMux <= addrHX;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0100;
                                        end
                                    // SUB #opr8i, CMP #opr8i, SBC #opr8i, CPX #opr8i
                                    // AND #opr8i, BIT #opr8i, LDA #opr8i
                                    // EOR #opr8i, ADC #opr8i, ORA #opr8i, ADD #opr8i
                                    8'hA0, 8'hA1, 8'hA2, 8'hA3, 8'hA4, 8'hA5, 8'hA6, 8'hA8, 8'hA9, 8'hAA, 8'hAB, 8'hAE :		// LDX #opr8i
                                        begin
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0101;
                                        end
                                    // SUB oprx8,X, CMP oprx8,X, SBC oprx8,X, CPX oprx8,X
                                    // AND oprx8,X, BIT oprx8,X, LDA oprx8,X, STA oprx8,X
                                    // EOR oprx8,X, ADC oprx8,X, ORA oprx8,X, ADD oprx8,X
                                    8'hE0, 8'hE1, 8'hE2, 8'hE3, 8'hE4, 8'hE5, 8'hE6, 8'hE7, 8'hE8, 8'hE9, 8'hEA, 8'hEB, 8'hEC, 8'hEE, 8'hEF :		// JMP oprx8,X, LDX oprx8,X, STX oprx8,X
                                        begin
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0100;
                                        end
                                    // SUB ,X, CMP ,X, SBC ,X, CPX ,X
                                    // AND ,X, BIT ,X, LDA ,X
                                    // EOR ,X, ADC ,X, ORA ,X, ADD ,X
                                    8'hF0, 8'hF1, 8'hF2, 8'hF3, 8'hF4, 8'hF5, 8'hF6, 8'hF8, 8'hF9, 8'hFA, 8'hFB, 8'hFE :		// LDX ,X
                                        begin
                                            addrMux <= addrHX;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0101;
                                        end
                                    8'hFC :		// JMP ,X
                                        begin
                                            regPC <= {8'h00, regX};
                                            mainFSM <= 4'b0010;
                                        end
                                    8'hF7 :		// STA ,X
                                        begin
                                            wr <= CPUwrite;
                                            flagN <= regA[7];
                                            if (regA == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            dataMux <= outA;
                                            addrMux <= addrHX;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0101;
                                        end
                                    8'hFF :		// STX ,X
                                        begin
                                            wr <= CPUwrite;
                                            flagN <= regX[7];
                                            if (regX == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            dataMux <= outX;
                                            addrMux <= addrHX;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0101;
                                        end
                                    8'h40 :		// NEGA
                                        begin
                                            regA <= 8'h00 - regA;
                                            tres = 8'h00 - regA;
                                            flagN <= tres[7];
                                            if (tres == 8'h00)
                                            begin
                                                flagZ <= 1'b1;
                                                flagC <= 1'b0;
                                            end
                                            else
                                            begin
                                                flagC <= 1'b1;
                                                flagZ <= 1'b0;
                                            end
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h42 :		// MUL
                                        begin
                                            flagH <= 1'b0;
                                            flagC <= 1'b0;
                                            regA <= prod[7:0];
                                            regX <= prod[15:8];
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h43 :		// COMA
                                        begin
                                            regA <= regA ^ 8'hFF;
                                            tres = regA ^ 8'hFF;
                                            flagC <= 1'b1;
                                            flagN <= tres[7];
                                            if (tres == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h44 :		// LSRA
                                        begin
                                            regA <= {1'b0, regA[7:1]};
                                            tres = {1'b0, regA[7:1]};
                                            flagN <= 1'b0;
                                            flagC <= regA[0];
                                            if (tres == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h46 :		// RORA
                                        begin
                                            regA <= {flagC, regA[7:1]};
                                            tres = {flagC, regA[7:1]};
                                            flagN <= flagC;
                                            flagC <= regA[0];
                                            if (tres == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h47 :		// ASRA
                                        begin
                                            regA <= {regA[7], regA[7:1]};
                                            tres = {regA[7], regA[7:1]};
                                            flagN <= regA[7];
                                            flagC <= regA[0];
                                            if (tres == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h48 :		// LSLA
                                        begin
                                            regA <= {regA[6:0], 1'b0};
                                            tres = {regA[6:0], 1'b0};
                                            flagN <= regA[6];
                                            flagC <= regA[7];
                                            if (tres == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h49 :		// ROLA
                                        begin
                                            regA <= {regA[6:0], flagC};
                                            tres = {regA[6:0], flagC};
                                            flagN <= regA[6];
                                            flagC <= regA[7];
                                            if (tres == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h4A :		// DECA
                                        begin
                                            regA <= regA - 1;
                                            tres = regA - 1;
                                            flagN <= tres[7];
                                            if (tres == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h4C :		// INCA
                                        begin
                                            regA <= regA + 1;
                                            tres = regA + 1;
                                            flagN <= tres[7];
                                            if (tres == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h4D :		// TSTA
                                        begin
                                            flagN <= regA[7];
                                            if (regA == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h4F :		// CLRA
                                        begin
                                            regA <= 8'h00;
                                            flagN <= 1'b0;
                                            flagZ <= 1'b1;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h50 :		// NEGX
                                        begin
                                            regX <= 8'h00 - regX;
                                            tres = 8'h00 - regX;
                                            flagN <= tres[7];
                                            if (tres == 8'h00)
                                            begin
                                                flagZ <= 1'b1;
                                                flagC <= 1'b0;
                                            end
                                            else
                                            begin
                                                flagC <= 1'b1;
                                                flagZ <= 1'b0;
                                            end
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h53 :		// COMX
                                        begin
                                            regX <= regX ^ 8'hFF;
                                            tres = regX ^ 8'hFF;
                                            flagC <= 1'b1;
                                            flagN <= tres[7];
                                            if (tres == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h54 :		// LSRX
                                        begin
                                            regX <= {1'b0, regX[7:1]};
                                            tres = {1'b0, regX[7:1]};
                                            flagN <= 1'b0;
                                            flagC <= regX[0];
                                            if (tres == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h56 :		// RORX
                                        begin
                                            regX <= {flagC, regX[7:1]};
                                            tres = {flagC, regX[7:1]};
                                            flagN <= flagC;
                                            flagC <= regX[0];
                                            if (tres == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h57 :		// ASRX
                                        begin
                                            regX <= {regX[7], regX[7:1]};
                                            tres = {regX[7], regX[7:1]};
                                            flagN <= regX[7];
                                            flagC <= regX[0];
                                            if (tres == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h58 :		// LSLX
                                        begin
                                            regX <= {regX[6:0], 1'b0};
                                            tres = {regX[6:0], 1'b0};
                                            flagN <= regX[6];
                                            flagC <= regX[7];
                                            if (tres == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h59 :		// ROLX
                                        begin
                                            regX <= {regX[6:0], flagC};
                                            tres = {regX[6:0], flagC};
                                            flagN <= regX[6];
                                            flagC <= regX[7];
                                            if (tres == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h5A :		// DECX
                                        begin
                                            regX <= regX[7:0] - 1;
                                            tres = regX[7:0] - 1;
                                            flagN <= tres[7];
                                            if (tres == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h5C :		// INCX
                                        begin
                                            regX <= regX[7:0] + 1;
                                            tres = regX[7:0] + 1;
                                            flagN <= tres[7];
                                            if (tres == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h5D :		// TSTX
                                        begin
                                            flagN <= regX[7];
                                            if (regX == 8'h00)
                                                flagZ <= 1'b1;
                                            else
                                                flagZ <= 1'b0;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h5F :		// CLRX
                                        begin
                                            regX <= 8'h00;
                                            flagN <= 1'b0;
                                            flagZ <= 1'b1;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    // NEG oprx8,X, COM oprx8,X, LSR oprx8,X, ROR oprx8,X
                                    // ASR oprx8,X, LSL oprx8,X, ROL oprx8,X, DEC oprx8,X
                                    8'h60, 8'h63, 8'h64, 8'h66, 8'h67, 8'h68, 8'h69, 8'h6A, 8'h6C, 8'h6D, 8'h6F :		// INC oprx8,X, TST oprx8,X, CLR oprx8,X
                                        begin
                                            temp <= {8'h00, regX};
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0011;
                                        end
                                    8'h7F :		// CLR ,X
                                        begin
                                            flagN <= 1'b0;
                                            flagZ <= 1'b1;
                                            addrMux <= addrHX;
                                            dataMux <= outHelp;
                                            wr <= CPUwrite;
                                            help <= 8'h00;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0011;
                                        end
                                    8'h80, 8'h81 :		// RTI, RTS
                                        begin
                                            regSP <= regSP + 1;
                                            addrMux <= addrSP;
                                            mainFSM <= 4'b0011;
                                        end
                                    8'h83 :		// SWI
                                        begin
                                            regPC <= regPC + 1;
                                            addrMux <= addrSP;
                                            mainFSM <= 4'b0011;
                                        end
                                    8'h8E :		// STOP currently unsupported
                                        begin
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h8F :		// WAIT currently unsupported
                                        begin
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h97 :		// TAX
                                        begin
                                            regX <= regA;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h98, 8'h99 :		// CLC, SEC
                                        begin
                                            flagC <= datain[0];
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h9A, 8'h9B :		// CLI, SEI  ATTENTION!!!
                                        begin
                                            flagI <= datain[0];
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h9C :		// RSP
                                        begin
                                            regSP <= 16'h00FF;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h31, 8'h41, 8'h35, 8'h3B, 8'h45, 8'h4B, 8'h4E, 8'h51, 8'h52, 8'h55, 8'h5B, 8'h5E, 8'h61, 8'h62, 8'h65, 8'h6B, 8'h6E, 8'h71, 8'h72, 8'h75, 8'h7B, 8'h7E, 8'h84, 8'h85, 8'h86, 8'h87, 8'h88, 8'h89, 8'h8A, 8'h8B, 8'h8C, 8'h8D, 8'h90, 8'h91, 8'h92, 8'h93, 8'h94, 8'h95, 8'h9D, 8'h9E, 8'hA7, 8'hAC, 8'hAF :		// NOP
                                        begin
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'h9F :		// TXA
                                        begin
                                            regA <= regX;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0010;
                                        end
                                    8'hAD, 8'hBD, 8'hED :		// BSR rel, JSR opr8a, JSR oprx8,X
                                        begin
                                            temp <= regPC + 2;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0011;
                                        end
                                    8'hCD, 8'hDD :		// JSR opr16a, JSR oprx16,X
                                        begin
                                            temp <= regPC + 3;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0011;
                                        end
                                    8'hFD :		// JSR ,X
                                        begin
                                            temp <= regPC + 1;
                                            wr <= CPUwrite;
                                            addrMux <= addrSP;
                                            dataMux <= outTL;
                                            regPC <= regPC + 1;
                                            mainFSM <= 4'b0100;
                                        end
                                    
                                    default :
                                        mainFSM <= 4'b0000;
                                endcase
                            end
                        end
                    // datain
                    // trace = '1'
                    
                    4'b0011 :		//##################### instruction cycle 2  
                        case (opcode)
                            // BRSET n,opr8a,rel
                            // BRCLR n,opr8a,rel
                            // BSET n,opr8a
                            // BCLR n,opr8a
                            // NEG opr8a, COM opr8a, LSR opr8a, ROR opr8a
                            // ASR opr8a, LSL opr8a, ROL opr8a, DEC opr8a, INC opr8a
                            8'h00, 8'h02, 8'h04, 8'h06, 8'h08, 8'h0A, 8'h0C, 8'h0E, 8'h01, 8'h03, 8'h05, 8'h07, 8'h09, 8'h0B, 8'h0D, 8'h0F, 8'h10, 8'h12, 8'h14, 8'h16, 8'h18, 8'h1A, 8'h1C, 8'h1E, 8'h11, 8'h13, 8'h15, 8'h17, 8'h19, 8'h1B, 8'h1D, 8'h1F, 8'h30, 8'h33, 8'h34, 8'h36, 8'h37, 8'h38, 8'h39, 8'h3A, 8'h3C, 8'h3D :		// TST opr8a
                                begin
                                    temp[7:0] <= datain;
                                    addrMux <= addrTM;
                                    regPC <= regPC + 1;
                                    mainFSM <= 4'b0100;
                                end
                            // SUB opr16a, CMP opr16a, SBC opr16a, CPX opr16a
                            // AND opr16a, BIT opr16a, LDA opr16a, STA opr16a
                            // EOR opr16a, ADC opr16a, ORA opr16a, ADD opr16a
                            // JMP opr16a, LDX opr16a, STX opr16a
                            // SUB oprx16,X, CMP oprx16,X, SBC oprx16,X, CPX oprx16,X
                            // AND oprx16,X, BIT oprx16,X, LDA oprx16,X, STA oprx16,X
                            // EOR oprx16,X, ADC oprx16,X, ORA oprx16,X, ADD oprx16,X
                            8'hC0, 8'hC1, 8'hC2, 8'hC3, 8'hC4, 8'hC5, 8'hC6, 8'hC7, 8'hC8, 8'hC9, 8'hCA, 8'hCB, 8'hCC, 8'hCE, 8'hCF, 8'hD0, 8'hD1, 8'hD2, 8'hD3, 8'hD4, 8'hD5, 8'hD6, 8'hD7, 8'hD8, 8'hD9, 8'hDA, 8'hDB, 8'hDC, 8'hDE, 8'hDF :		// JMP oprx16,X, LDX oprx16,X, STX oprx16,X
                                begin
                                    temp[15:8] <= datain;
                                    regPC <= regPC + 1;
                                    mainFSM <= 4'b0100;
                                end
                            8'hB7 :		// STA opr8a
                                begin
                                    wr <= CPUwrite;
                                    dataMux <= outA;
                                    temp[7:0] <= datain;
                                    addrMux <= addrTM;
                                    regPC <= regPC + 1;
                                    mainFSM <= 4'b0101;
                                end
                            8'hBF :		// STX opr8a
                                begin
                                    wr <= CPUwrite;
                                    dataMux <= outX;
                                    temp[7:0] <= datain;
                                    addrMux <= addrTM;
                                    regPC <= regPC + 1;
                                    mainFSM <= 4'b0101;
                                end
                            // SUB opr8a, CMP opr8a, SBC opr8a, CPX opr8a
                            // AND opr8a, BIT opr8a, LDA opr8a
                            // EOR opr8a, ADC opr8a, ORA opr8a, ADD opr8a
                            8'hB0, 8'hB1, 8'hB2, 8'hB3, 8'hB4, 8'hB5, 8'hB6, 8'hB8, 8'hB9, 8'hBA, 8'hBB, 8'hBE :		// LDX opr8a
                                begin
                                    temp[7:0] <= datain;
                                    addrMux <= addrTM;
                                    regPC <= regPC + 1;
                                    mainFSM <= 4'b0101;
                                end
                            
                            8'h20 :		// BRA
                                begin
                                    if (datain[7] == 1'b0)
                                        regPC <= regPC + ({8'h00, datain}) + 16'h0001;
                                    else
                                        regPC <= regPC + ({8'hFF, datain}) + 16'h0001;
                                    mainFSM <= 4'b0010;
                                end
                            8'h21 :		// BRN
                                begin
                                    regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'h22, 8'h23 :		// BHI, BLS
                                begin
                                    if ((flagC | flagZ) == opcode[0])
                                    begin
                                        if (datain[7] == 1'b0)
                                            regPC <= regPC + ({8'h00, datain}) + 16'h0001;
                                        else
                                            regPC <= regPC + ({8'hFF, datain}) + 16'h0001;
                                    end
                                    else
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'h24, 8'h25 :		// BCC, BCS
                                begin
                                    if (flagC == opcode[0])
                                    begin
                                        if (datain[7] == 1'b0)
                                            regPC <= regPC + ({8'h00, datain}) + 16'h0001;
                                        else
                                            regPC <= regPC + ({8'hFF, datain}) + 16'h0001;
                                    end
                                    else
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'h26, 8'h27 :		// BNE, BEQ
                                begin
                                    if (flagZ == opcode[0])
                                    begin
                                        if (datain[7] == 1'b0)
                                            regPC <= regPC + ({8'h00, datain}) + 16'h0001;
                                        else
                                            regPC <= regPC + ({8'hFF, datain}) + 16'h0001;
                                    end
                                    else
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'h28, 8'h29 :		// BHCC, BHCS
                                begin
                                    if (flagH == opcode[0])
                                    begin
                                        if (datain[7] == 1'b0)
                                            regPC <= regPC + ({8'h00, datain}) + 16'h0001;
                                        else
                                            regPC <= regPC + ({8'hFF, datain}) + 16'h0001;
                                    end
                                    else
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'h2A, 8'h2B :		// BPL, BMI
                                begin
                                    if (flagN == opcode[0])
                                    begin
                                        if (datain[7] == 1'b0)
                                            regPC <= regPC + ({8'h00, datain}) + 16'h0001;
                                        else
                                            regPC <= regPC + ({8'hFF, datain}) + 16'h0001;
                                    end
                                    else
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'h2C, 8'h2D :		// BMC, BMS
                                begin
                                    if (flagI == opcode[0])
                                    begin
                                        if (datain[7] == 1'b0)
                                            regPC <= regPC + ({8'h00, datain}) + 16'h0001;
                                        else
                                            regPC <= regPC + ({8'hFF, datain}) + 16'h0001;
                                    end
                                    else
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'h2E, 8'h2F :		// BIL, BIH
                                begin
                                    if (irq == opcode[0])
                                    begin
                                        if (datain[7] == 1'b0)
                                            regPC <= regPC + ({8'h00, datain}) + 16'h0001;
                                        else
                                            regPC <= regPC + ({8'hFF, datain}) + 16'h0001;
                                    end
                                    else
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'h3F, 8'h6F :		// CLR opr8a, CLR oprx8,X
                                begin
                                    wr <= CPUwrite;
                                    case (opcode)
                                        8'h3F :
                                            temp[7:0] <= datain;
                                        8'h6F :
                                            temp <= temp + ({8'h00, datain});
                                        default :
                                            temp <= 16'h0000;
                                    endcase
                                    addrMux <= addrTM;
                                    dataMux <= outHelp;
                                    flagZ <= 1'b1;
                                    flagN <= 1'b0;
                                    help <= 8'h00;
                                    regPC <= regPC + 1;
                                    mainFSM <= 4'b0100;
                                end
                            // NEG oprx8,X, COM oprx8,X, LSR oprx8,X, ROR oprx8,X
                            // ASR oprx8,X, LSL oprx8,X, ROL oprx8,X, DEC oprx8,X
                            8'h60, 8'h63, 8'h64, 8'h66, 8'h67, 8'h68, 8'h69, 8'h6A, 8'h6C, 8'h6D :		// INC oprx8,X, TST oprx8,X
                                begin
                                    temp <= temp + ({8'h00, datain});
                                    regPC <= regPC + 1;
                                    addrMux <= addrTM;
                                    mainFSM <= 4'b0100;
                                end
                            8'h7F :		// CLR ,X
                                begin
                                    wr <= CPUread;
                                    addrMux <= addrPC;
                                    mainFSM <= 4'b0010;
                                end
                            8'h80, 8'h82 :		// RTI, RTT
                                begin
                                    flagH <= datain[4];
                                    flagI <= datain[3];		//----- PLEASE RESTORE AT LATER TIME
                                    flagN <= datain[2];
                                    flagZ <= datain[1];
                                    flagC <= datain[0];
                                    regSP <= regSP + 1;
                                    mainFSM <= 4'b0100;
                                end
                            8'h81 :		// RTS
                                begin
                                    regPC[15:8] <= datain;
                                    regSP <= regSP + 1;
                                    mainFSM <= 4'b0100;
                                end
                            8'h83 :		// SWI
                                begin
                                    wr <= CPUwrite;
                                    dataMux <= outPCL;
                                    mainFSM <= 4'b0100;
                                end
                            8'hAD, 8'hBD, 8'hED :		// BSR rel, JSR opr8a, JSR oprx8,X
                                begin
                                    regPC <= regPC + 1;
                                    wr <= CPUwrite;
                                    help <= datain;
                                    addrMux <= addrSP;
                                    dataMux <= outPCL;
                                    mainFSM <= 4'b0100;
                                end
                            8'hBC :		// JMP opr8a
                                begin
                                    regPC <= ({8'h00, datain});
                                    mainFSM <= 4'b0010;
                                end
                            8'hCD, 8'hDD :		// JSR opr16a, JSR oprx16,X
                                begin
                                    temp[15:8] <= datain;
                                    regPC <= regPC + 1;
                                    mainFSM <= 4'b0100;
                                end
                            
                            default :
                                mainFSM <= 4'b0000;
                        endcase
                    // opcode
                    
                    4'b0100 :		//##################### instruction cycle 3
                        case (opcode)
                            // BRSET n,opr8a,rel
                            8'h00, 8'h02, 8'h04, 8'h06, 8'h08, 8'h0A, 8'h0C, 8'h0E, 8'h01, 8'h03, 8'h05, 8'h07, 8'h09, 8'h0B, 8'h0D, 8'h0F :		// BRCLR n,opr8a,rel
                                begin
                                    if ((datain & {8{mask1[(opcode[3:1])]}}) != 8'h00)
                                        flagC <= 1'b1;
                                    else
                                        flagC <= 1'b0;
                                    addrMux <= addrPC;
                                    mainFSM <= 4'b0101;
                                end
                            // BSET n,opr8a
                            8'h10, 8'h12, 8'h14, 8'h16, 8'h18, 8'h1A, 8'h1C, 8'h1E, 8'h11, 8'h13, 8'h15, 8'h17, 8'h19, 8'h1B, 8'h1D, 8'h1F :		// BCLR n,opr8a
                                begin
                                    wr <= CPUwrite;
                                    dataMux <= outHelp;
                                    if (opcode[0] == 1'b0)
                                        help <= datain | {8{mask1[(opcode[3:1])]}};
                                    else
                                        help <= datain & {8{mask0[(opcode[3:1])]}};
                                    mainFSM <= 4'b0101;
                                end
                            // SUB opr16a, CMP opr16a, SBC opr16a, CPX opr16a
                            // AND opr16a, BIT opr16a, LDA opr16a
                            // EOR opr16a, ADC opr16a, ORA opr16a, ADD opr16a
                            // LDX opr16a
                            // SUB oprx16,X, CMP oprx16,X, SBC oprx16,X, CPX oprx16,X
                            // AND oprx16,X, BIT oprx16,X, LDA oprx16,X
                            // EOR oprx16,X, ADC oprx16,X, ORA oprx16,X, ADD oprx16,X
                            // LDX oprx16,X
                            // SUB oprx8,X, CMP oprx8,X, SBC oprx8,X, CPX oprx8,X
                            // AND oprx8,X, BIT oprx8,X, LDA oprx8,X
                            // EOR oprx8,X, ADC oprx8,X, ORA oprx8,X, ADD oprx8,X
                            8'hC0, 8'hC1, 8'hC2, 8'hC3, 8'hC4, 8'hC5, 8'hC6, 8'hC8, 8'hC9, 8'hCA, 8'hCB, 8'hCE, 8'hD0, 8'hD1, 8'hD2, 8'hD3, 8'hD4, 8'hD5, 8'hD6, 8'hD8, 8'hD9, 8'hDA, 8'hDB, 8'hDE, 8'hE0, 8'hE1, 8'hE2, 8'hE3, 8'hE4, 8'hE5, 8'hE6, 8'hE8, 8'hE9, 8'hEA, 8'hEB, 8'hEE :		// LDX oprx8,X
                                begin
                                    temp[7:0] <= datain;
                                    case (opcode[7:4])
                                        4'hC :
                                            addrMux <= addrTM;
                                        4'hD :
                                            addrMux <= addrX2;
                                        4'hE :
                                            addrMux <= addrX1;
                                        default :
                                            ;
                                    endcase
                                    regPC <= regPC + 1;
                                    mainFSM <= 4'b0101;
                                end
                            8'hCC :		// JMP opr16a
                                begin
                                    regPC <= {temp[15:8], datain};
                                    mainFSM <= 4'b0010;
                                end
                            8'hDC :		// JMP oprx16,X
                                begin
                                    regPC <= ({temp[15:8], datain}) + ({8'h00, regX});
                                    mainFSM <= 4'b0010;
                                end
                            8'hEC :		// JMP oprx8,X
                                begin
                                    regPC <= ({8'h00, datain}) + ({8'h00, regX});
                                    mainFSM <= 4'b0010;
                                end
                            8'hC7 :		// STA opr16a
                                begin
                                    wr <= CPUwrite;
                                    flagN <= regA[7];
                                    if (regA == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    dataMux <= outA;
                                    temp[7:0] <= datain;
                                    addrMux <= addrTM;
                                    regPC <= regPC + 1;
                                    mainFSM <= 4'b0101;
                                end
                            8'hD7 :		// STA oprx16,X
                                begin
                                    wr <= CPUwrite;
                                    flagN <= regA[7];
                                    if (regA == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    dataMux <= outA;
                                    temp[7:0] <= datain;
                                    addrMux <= addrX2;
                                    regPC <= regPC + 1;
                                    mainFSM <= 4'b0101;
                                end
                            8'hE7 :		// STA oprx8,X
                                begin
                                    wr <= CPUwrite;
                                    flagN <= regA[7];
                                    if (regA == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    dataMux <= outA;
                                    temp[7:0] <= datain;
                                    addrMux <= addrX1;
                                    regPC <= regPC + 1;
                                    mainFSM <= 4'b0101;
                                end
                            8'hCF :		// STX opr16a
                                begin
                                    wr <= CPUwrite;
                                    flagN <= regX[7];
                                    if (regX == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    dataMux <= outX;
                                    temp[7:0] <= datain;
                                    addrMux <= addrTM;
                                    regPC <= regPC + 1;
                                    mainFSM <= 4'b0101;
                                end
                            8'hDF :		// STX oprx16,X
                                begin
                                    wr <= CPUwrite;
                                    flagN <= regX[7];
                                    if (regX == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    dataMux <= outX;
                                    temp[7:0] <= datain;
                                    addrMux <= addrX2;
                                    regPC <= regPC + 1;
                                    mainFSM <= 4'b0101;
                                end
                            8'hEF :		// STX oprx8,X
                                begin
                                    wr <= CPUwrite;
                                    flagN <= regX[7];
                                    if (regX == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    dataMux <= outX;
                                    temp[7:0] <= datain;
                                    addrMux <= addrX1;
                                    regPC <= regPC + 1;
                                    mainFSM <= 4'b0101;
                                end
                            8'h30, 8'h60, 8'h70 :		// NEG opr8a, NEG oprx8,X, NEG ,X
                                begin
                                    wr <= CPUwrite;
                                    dataMux <= outHelp;
                                    help <= 8'h00 - datain;
                                    tres = 8'h00 - datain;
                                    flagN <= tres[7];
                                    if (tres == 8'h00)
                                    begin
                                        flagZ <= 1'b1;
                                        flagC <= 1'b0;
                                    end
                                    else
                                    begin
                                        flagC <= 1'b1;
                                        flagZ <= 1'b0;
                                    end
                                    mainFSM <= 4'b0101;
                                end
                            8'h33, 8'h63, 8'h73 :		// COM opr8a, COM oprx8,X, COM ,X
                                begin
                                    wr <= CPUwrite;
                                    dataMux <= outHelp;
                                    help <= datain ^ 8'hFF;
                                    tres = datain ^ 8'hFF;
                                    flagC <= 1'b1;
                                    flagN <= tres[7];
                                    if (tres == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    mainFSM <= 4'b0101;
                                end
                            8'h34, 8'h64, 8'h74 :		// LSR opr8a, LSR oprx8,X, LSR ,X
                                begin
                                    wr <= CPUwrite;
                                    dataMux <= outHelp;
                                    help <= {1'b0, datain[7:1]};
                                    tres = {1'b0, datain[7:1]};
                                    flagN <= 1'b0;
                                    flagC <= datain[0];
                                    if (tres == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    mainFSM <= 4'b0101;
                                end
                            8'h36, 8'h66, 8'h76 :		// ROR opr8a, ROR oprx8,X, ROR ,X
                                begin
                                    wr <= CPUwrite;
                                    dataMux <= outHelp;
                                    help <= {flagC, datain[7:1]};
                                    tres = {flagC, datain[7:1]};
                                    flagN <= flagC;
                                    flagC <= datain[0];
                                    if (tres == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    mainFSM <= 4'b0101;
                                end
                            8'h37, 8'h67, 8'h77 :		// ASR opr8a, ASR oprx8,X, ASR ,X
                                begin
                                    wr <= CPUwrite;
                                    dataMux <= outHelp;
                                    help <= {datain[7], datain[7:1]};
                                    tres = {datain[7], datain[7:1]};
                                    flagN <= datain[7];
                                    flagC <= datain[0];
                                    if (tres == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    mainFSM <= 4'b0101;
                                end
                            8'h38, 8'h68, 8'h78 :		// LSL opr8a, LSL oprx8,X, LSL ,X
                                begin
                                    wr <= CPUwrite;
                                    dataMux <= outHelp;
                                    help <= {datain[6:0], 1'b0};
                                    tres = {datain[6:0], 1'b0};
                                    flagN <= datain[6];
                                    flagC <= datain[7];
                                    if (tres == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    mainFSM <= 4'b0101;
                                end
                            8'h39, 8'h69, 8'h79 :		// ROL opr8a, ROL oprx8,X, ROL ,X
                                begin
                                    wr <= CPUwrite;
                                    dataMux <= outHelp;
                                    help <= {datain[6:0], flagC};
                                    tres = {datain[6:0], flagC};
                                    flagN <= datain[6];
                                    flagC <= datain[7];
                                    if (tres == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    mainFSM <= 4'b0101;
                                end
                            8'h3A, 8'h6A, 8'h7A :		// DEC opr8a, DEC oprx8,X, DEC ,X
                                begin
                                    wr <= CPUwrite;
                                    dataMux <= outHelp;
                                    help <= datain - 1;
                                    tres = datain - 1;
                                    flagN <= tres[7];
                                    if (tres == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    mainFSM <= 4'b0101;
                                end
                            8'h3C, 8'h6C, 8'h7C :		// INC opr8a, INC oprx8,X, INC ,X
                                begin
                                    wr <= CPUwrite;
                                    dataMux <= outHelp;
                                    help <= datain + 1;
                                    tres = datain + 1;
                                    flagN <= tres[7];
                                    if (tres == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    mainFSM <= 4'b0101;
                                end
                            8'h3D, 8'h6D, 8'h7D :		// TST opr8a, TST oprx8,X, TST ,X
                                begin
                                    flagN <= datain[7];
                                    if (datain == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    addrMux <= addrPC;
                                    mainFSM <= 4'b0010;
                                end
                            8'h3F, 8'h6F :		// CLR opr8a, CLR oprx8,X
                                begin
                                    wr <= CPUread;
                                    addrMux <= addrPC;
                                    mainFSM <= 4'b0010;
                                end
                            8'h80, 8'h82 :		// RTI, RTT
                                begin
                                    regA <= datain;
                                    regSP <= regSP + 1;
                                    mainFSM <= 4'b0101;
                                end
                            8'h81 :		// RTS
                                begin
                                    regPC[7:0] <= datain;
                                    addrMux <= addrPC;
                                    mainFSM <= 4'b0010;
                                end
                            8'h83 :		// SWI
                                begin
                                    regSP <= regSP - 1;
                                    dataMux <= outPCH;
                                    mainFSM <= 4'b0101;
                                end
                            8'hAD, 8'hBD, 8'hED :		// BSR rel, JSR opr8a, JSR oprx8,X
                                begin
                                    regSP <= regSP - 1;
                                    dataMux <= outPCH;
                                    mainFSM <= 4'b0101;
                                end
                            8'hFD :		// JSR ,X
                                begin
                                    regSP <= regSP - 1;
                                    dataMux <= outTH;
                                    mainFSM <= 4'b0101;
                                end
                            8'hCD, 8'hDD :		// JSR opr16a, JSR oprx16,X
                                begin
                                    wr <= CPUwrite;
                                    temp[7:0] <= datain;
                                    regPC <= regPC + 1;
                                    addrMux <= addrSP;
                                    dataMux <= outPCL;
                                    mainFSM <= 4'b0101;
                                end
                            
                            default :
                                mainFSM <= 4'b0000;
                        endcase
                    // opcode
                    
                    4'b0101 :		//##################### instruction cycle 4
                        case (opcode)
                            // BRSET n,opr8a,rel
                            8'h00, 8'h02, 8'h04, 8'h06, 8'h08, 8'h0A, 8'h0C, 8'h0E, 8'h01, 8'h03, 8'h05, 8'h07, 8'h09, 8'h0B, 8'h0D, 8'h0F :		// BRCLR n,opr8a,rel
                                begin
                                    if ((opcode[0] ^ flagC) == 1'b1)
                                    begin
                                        if (datain[7] == 1'b0)
                                            regPC <= regPC + ({8'h00, datain}) + 16'h0001;
                                        else
                                            regPC <= regPC + ({8'hFF, datain}) + 16'h0001;
                                    end
                                    else
                                        regPC <= regPC + 1;
                                    addrMux <= addrPC;
                                    mainFSM <= 4'b0010;
                                end
                            // BSET n,opr8a
                            // BCLR n,opr8a
                            // NEG opr8a, COM opr8a, LSR opr8a, ROR opr8a
                            // ASR opr8a, LSL opr8a, ROL opr8a, DEC opr8a, INC opr8a
                            // NEG oprx8,X, COM oprx8,X, LSR oprx8,X, ROR oprx8,X, ASR oprx8,X
                            // LSL oprx8,X, ROL oprx8,X, DEC oprx8,X, INC oprx8,X
                            // NEG ,X, COM ,X, LSR ,X, ROR ,X, ASR ,X, LSL ,X, ROL ,X
                            // DEC ,X, INC ,X
                            // STA opr8a, STX opr8a, STA opr16a, STX opr16a
                            // STA oprx16,X, STX oprx16,X, STA oprx8,X, STX oprx8,X
                            8'h10, 8'h12, 8'h14, 8'h16, 8'h18, 8'h1A, 8'h1C, 8'h1E, 8'h11, 8'h13, 8'h15, 8'h17, 8'h19, 8'h1B, 8'h1D, 8'h1F, 8'h30, 8'h33, 8'h34, 8'h36, 8'h37, 8'h38, 8'h39, 8'h3A, 8'h3C, 8'h60, 8'h63, 8'h64, 8'h66, 8'h67, 8'h68, 8'h69, 8'h6A, 8'h6C, 8'h70, 8'h73, 8'h74, 8'h76, 8'h77, 8'h78, 8'h79, 8'h7A, 8'h7C, 8'hB7, 8'hBF, 8'hC7, 8'hCF, 8'hD7, 8'hDF, 8'hE7, 8'hEF, 8'hF7, 8'hFF :		// STA ,X, STX ,X
                                begin
                                    wr <= CPUread;
                                    addrMux <= addrPC;
                                    mainFSM <= 4'b0010;
                                end
                            8'h80, 8'h82 :		// RTI, RTT
                                begin
                                    regX <= datain;
                                    regSP <= regSP + 1;
                                    mainFSM <= 4'b0110;
                                end
                            8'h83 :		// SWI
                                begin
                                    regSP <= regSP - 1;
                                    dataMux <= outX;
                                    help[7] <= 1'b1;
                                    help[6] <= 1'b1;
                                    help[5] <= 1'b1;
                                    help[4] <= flagH;
                                    help[3] <= flagI;
                                    help[2] <= flagN;
                                    help[1] <= flagZ;
                                    help[0] <= flagC;
                                    mainFSM <= 4'b0110;
                                end
                            8'hA0, 8'hB0, 8'hC0, 8'hD0, 8'hE0, 8'hF0 :		// SUB #opr8i, SUB opr8a, SUB opr16a, SUB oprx16,X, SUB oprx8,X, SUB ,X
                                begin
                                    addrMux <= addrPC;
                                    regA <= regA - datain;
                                    tres = regA - datain;
                                    flagN <= tres[7];
                                    if (tres == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    flagC <= (((~regA[7])) & datain[7]) | (datain[7] & tres[7]) | (tres[7] & ((~regA[7])));
                                    if (opcode == 8'hA0)
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'hA1, 8'hB1, 8'hC1, 8'hD1, 8'hE1, 8'hF1 :		// CMP #opr8i, CMP opr8a, CMP opr16a, CMP oprx16,X, CMP oprx8,X, CMP ,X
                                begin
                                    addrMux <= addrPC;
                                    tres = regA - datain;
                                    flagN <= tres[7];
                                    if (tres == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    flagC <= (((~regA[7])) & datain[7]) | (datain[7] & tres[7]) | (tres[7] & ((~regA[7])));
                                    if (opcode == 8'hA1)
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'hA2, 8'hB2, 8'hC2, 8'hD2, 8'hE2, 8'hF2 :		// SBC #opr8i, SBC opr8a, SBC opr16a, SBC oprx16,X, SBC oprx8,X, SBC ,X
                                begin
                                    addrMux <= addrPC;
                                    regA <= regA - datain - ({7'b0000000, flagC});
                                    tres = regA - datain - ({7'b0000000, flagC});
                                    flagN <= tres[7];
                                    if (tres == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    flagC <= (((~regA[7])) & datain[7]) | (datain[7] & tres[7]) | (tres[7] & ((~regA[7])));
                                    if (opcode == 8'hA2)
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'hA3, 8'hB3, 8'hC3, 8'hD3, 8'hE3, 8'hF3 :		// CPX #opr8i, CPX opr8a, CPX opr16a, CPX oprx16,X, CPX oprx8,X, CPX ,X
                                begin
                                    addrMux <= addrPC;
                                    tres = regX - datain;
                                    flagN <= tres[7];
                                    if (tres == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    flagC <= (((~regX[7])) & datain[7]) | (datain[7] & tres[7]) | (tres[7] & ((~regX[7])));
                                    if (opcode == 8'hA3)
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'hA4, 8'hB4, 8'hC4, 8'hD4, 8'hE4, 8'hF4 :		// AND #opr8i, AND opr8a, AND opr16a, AND oprx16,X, AND oprx8,X, AND ,X
                                begin
                                    addrMux <= addrPC;
                                    regA <= regA & datain;
                                    tres = regA & datain;
                                    flagN <= tres[7];
                                    if (tres == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    if (opcode == 8'hA4)
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'hA5, 8'hB5, 8'hC5, 8'hD5, 8'hE5, 8'hF5 :		// BIT #opr8i, BIT opr8a, BIT opr16a, BIT oprx16,X, BIT oprx8,X, BIT ,X
                                begin
                                    addrMux <= addrPC;
                                    tres = regA & datain;
                                    flagN <= tres[7];
                                    if (tres == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    if (opcode == 8'hA5)
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'hA6, 8'hB6, 8'hC6, 8'hD6, 8'hE6, 8'hF6 :		// LDA #opr8i, LDA opr8a, LDA opr16a, LDA oprx16,X, LDA oprx8,X, LDA ,X
                                begin
                                    addrMux <= addrPC;
                                    regA <= datain;
                                    flagN <= datain[7];
                                    if (datain == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    if (opcode == 8'hA6)
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'hA8, 8'hB8, 8'hC8, 8'hD8, 8'hE8, 8'hF8 :		// EOR #opr8i, EOR opr8a, EOR opr16a, EOR oprx16,X, EOR oprx8,X, EOR ,X
                                begin
                                    addrMux <= addrPC;
                                    regA <= regA ^ datain;
                                    tres = regA ^ datain;
                                    flagN <= tres[7];
                                    if (tres == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    if (opcode == 8'hA8)
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'hA9, 8'hB9, 8'hC9, 8'hD9, 8'hE9, 8'hF9 :		// ADC #opr8i, ADC opr8a, ADC opr16a, ADC oprx16,X, ADC oprx8,X, ADC ,X
                                begin
                                    addrMux <= addrPC;
                                    regA <= regA + datain + ({7'b0000000, flagC});
                                    tres = regA + datain + ({7'b0000000, flagC});
                                    flagN <= tres[7];
                                    if (tres == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    flagH <= (regA[3] & datain[3]) | (datain[3] & ((~tres[3]))) | (((~tres[3])) & regA[3]);
                                    flagC <= (regA[7] & datain[7]) | (datain[7] & ((~tres[7]))) | (((~tres[7])) & regA[7]);
                                    if (opcode == 8'hA9)
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'hAA, 8'hBA, 8'hCA, 8'hDA, 8'hEA, 8'hFA :		// ORA #opr8i, ORA opr8a, ORA opr16a, ORA oprx16,X, ORA oprx8,X, ORA ,X
                                begin
                                    addrMux <= addrPC;
                                    regA <= regA | datain;
                                    tres = regA | datain;
                                    flagN <= tres[7];
                                    if (tres == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    if (opcode == 8'hAA)
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'hAB, 8'hBB, 8'hCB, 8'hDB, 8'hEB, 8'hFB :		// ADD #opr8i, ADD opr8a, ADD opr16a, ADD oprx16,X, ADD oprx8,X, ADD ,X
                                begin
                                    addrMux <= addrPC;
                                    regA <= regA + datain;
                                    tres = regA + datain;
                                    flagN <= tres[7];
                                    if (tres == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    flagH <= (regA[3] & datain[3]) | (datain[3] & ((~tres[3]))) | (((~tres[3])) & regA[3]);
                                    flagC <= (regA[7] & datain[7]) | (datain[7] & ((~tres[7]))) | (((~tres[7])) & regA[7]);
                                    if (opcode == 8'hAB)
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'hAE, 8'hBE, 8'hCE, 8'hDE, 8'hEE, 8'hFE :		// LDX #opr8i, LDX opr8a, LDX opr16a, LDX oprx16,X, LDX oprx8,X, LDX ,X
                                begin
                                    addrMux <= addrPC;
                                    regX <= datain;
                                    flagN <= datain[7];
                                    if (datain == 8'h00)
                                        flagZ <= 1'b1;
                                    else
                                        flagZ <= 1'b0;
                                    if (opcode == 8'hAE)
                                        regPC <= regPC + 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'hAD :		// BSR rel
                                begin
                                    wr <= CPUread;
                                    addrMux <= addrPC;
                                    if (help[7] == 1'b0)
                                        regPC <= regPC + ({8'h00, help});
                                    else
                                        regPC <= regPC + ({8'hFF, help});
                                    regSP <= regSP - 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'hBD :		// JSR opr8a
                                begin
                                    wr <= CPUread;
                                    addrMux <= addrPC;
                                    regPC <= {8'h00, help};
                                    regSP <= regSP - 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'hCD, 8'hDD :		// JSR opr16a, JSR oprx16,X
                                begin
                                    regSP <= regSP - 1;
                                    dataMux <= outPCH;
                                    mainFSM <= 4'b0110;
                                end
                            8'hED :		// JSR oprx8,X
                                begin
                                    wr <= CPUread;
                                    addrMux <= addrPC;
                                    regPC <= ({8'h00, help}) + ({8'h00, regX});
                                    regSP <= regSP - 1;
                                    mainFSM <= 4'b0010;
                                end
                            8'hFD :		// JSR ,X
                                begin
                                    wr <= CPUread;
                                    addrMux <= addrPC;
                                    regPC <= ({8'h00, regX});
                                    regSP <= regSP - 1;
                                    mainFSM <= 4'b0010;
                                end
                            
                            default :
                                mainFSM <= 4'b0000;
                        endcase
                    // opcode
                    
                    4'b0110 :		//##################### instruction cycle 5
                        case (opcode)
                            8'h80, 8'h82 :		// RTI, RTT
                                begin
                                    regPC[15:8] <= datain;
                                    regSP <= regSP + 1;
                                    mainFSM <= 4'b0111;
                                end
                            8'h83 :		// SWI
                                begin
                                    regSP <= regSP - 1;
                                    dataMux <= outA;
                                    mainFSM <= 4'b0111;
                                end
                            8'hCD :		// JSR opr16a
                                begin
                                    wr <= CPUread;
                                    addrMux <= addrPC;
                                    regSP <= regSP - 1;
                                    regPC <= temp;
                                    mainFSM <= 4'b0010;
                                end
                            8'hDD :		// JSR oprx16,X
                                begin
                                    wr <= CPUread;
                                    addrMux <= addrPC;
                                    regSP <= regSP - 1;
                                    regPC <= temp + ({8'h00, regX});
                                    mainFSM <= 4'b0010;
                                end
                            
                            default :
                                mainFSM <= 4'b0000;
                        endcase
                    // opcode
                    
                    4'b0111 :		//##################### instruction cycle 6
                        case (opcode)
                            8'h80, 8'h82 :		// RTI, RTT
                                begin
                                    regPC[7:0] <= datain;
                                    addrMux <= addrPC;
                                    mainFSM <= 4'b0010;
                                end
                            8'h83 :		// SWI
                                begin
                                    regSP <= regSP - 1;
                                    dataMux <= outHelp;
                                    flagI <= 1'b1;
                                    if (trace == 1'b0)
                                    begin
                                        if (irqRequest == 1'b0)
                                            temp <= 16'hFFFC;		// SWI vector
                                        else
                                        begin
                                            irqRequest <= 1'b0;
                                            temp <= 16'hFFFA;		// IRQ vector
                                        end
                                        mainFSM <= 4'b1000;
                                    end
                                    else
                                    begin
                                        temp <= 16'hFFF8;		// trace vector
                                        mainFSM <= 4'b1011;
                                    end
                                end
                            
                            default :
                                mainFSM <= 4'b0000;
                        endcase
                    // opcode
                    4'b1000 :		//##################### instruction cycle 7
                        case (opcode)
                            8'h83 :		// SWI
                                begin
                                    wr <= CPUread;
                                    addrMux <= addrTM;
                                    regSP <= regSP - 1;
                                    mainFSM <= 4'b1001;
                                end
                            
                            default :
                                mainFSM <= 4'b0000;
                        endcase
                    4'b1001 :		//##################### instruction cycle 8
                        case (opcode)
                            8'h83 :		// SWI
                                begin
                                    regPC[15:8] <= datain;
                                    temp <= temp + 1;
                                    mainFSM <= 4'b1010;
                                end
                            
                            default :
                                mainFSM <= 4'b0000;
                        endcase
                    4'b1010 :		//##################### instruction cycle 9
                        case (opcode)
                            8'h83 :		// SWI
                                begin
                                    regPC[7:0] <= datain;
                                    addrMux <= addrPC;
                                    mainFSM <= 4'b0010;
                                end
                            
                            default :
                                mainFSM <= 4'b0000;
                        endcase
                    4'b1011 :		//##################### instruction cycle 6a, trace
                        begin
                            regSP <= regSP - 1;
                            dataMux <= outCode;
                            trace <= 1'b0;
                            trace_i <= 1'b0;
                            mainFSM <= 4'b1000;
                        end
                    
                    default :
                        mainFSM <= 4'b0000;
                endcase
            end
    end
    
endmodule
// mainFSM
